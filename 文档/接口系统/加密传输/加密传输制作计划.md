# 加密传输制作计划

## 整体方案

采用 X25519 ECDH 密钥协商 + AES-256-GCM 对称加密的混合加密方案，通过设备指纹绑定会话实现安全可复用的加密传输。

核心思路：
- 客户端生成设备指纹（包含 IP、UA、屏幕分辨率、时区等设备信息的哈希值）
- 同一指纹的会话可复用，避免每次请求都重新协商密钥
- 通过指纹级别的频率限制防止滥用，而非简单的 IP 限流

```
┌──────────┐                              ┌──────────┐
│  客户端   │                              │  服务端   │
└────┬─────┘                              └────┬─────┘
     │                                        │
     │  生成设备指纹（IP+UA+屏幕+时区等哈希）    │
     │                                        │
     │  1. POST /jiekou/jiami/gongyao          │
     │  请求体: { zhiwen: "设备指纹哈希" }      │
     │ ────────────────────────────────────►   │
     │                                        │  校验指纹频率限制
     │                                        │  检查该指纹是否已有活跃会话
     │                                        │  ├─ 有 → 直接返回已有会话
     │                                        │  └─ 无 → 生成新 X25519 密钥对
     │                                        │         私钥+指纹存入 Redis
     │  2. 返回服务端公钥 + 会话ID              │
     │ ◄────────────────────────────────────   │
     │                                        │
     │  生成客户端临时密钥对                     │
     │  ECDH(客户端私钥, 服务端公钥)             │
     │  → 共享密钥 → HKDF 派生 AES 密钥         │
     │  本地缓存 huihuaid + AES 密钥             │
     │                                        │
     │  3. POST 加密业务请求                    │
     │  请求头: X-Huihua-Id + X-Kehugongyao    │
     │  请求体: AES-GCM 加密的业务数据           │
     │ ────────────────────────────────────►   │
     │                                        │  从 Redis 取出服务端私钥
     │                                        │  ECDH → HKDF → AES 密钥
     │                                        │  解密 → 处理业务 → 加密响应
     │  4. 返回加密响应                         │
     │ ◄────────────────────────────────────   │
     │  AES-GCM 解密 → 得到业务数据             │
     │                                        │
     │  （后续请求复用同一会话，无需重新协商）     │
     └─────────────────────────────────────────┘
```

## 前端交换流程

前端调用加密接口的完整步骤：

1. 页面加载时生成设备指纹（SHA-256 哈希），包含：IP（由服务端从请求中提取）、User-Agent、屏幕分辨率、时区偏移、语言、平台等
2. 调用 `POST /jiekou/jiami/gongyao`，提交 `{ zhiwen: "指纹哈希" }`，获得 `{ huihuaid, gongyao }`
3. 前端本地生成 X25519 临时密钥对，用自己的私钥 + 服务端公钥 → ECDH → HKDF → 得到 AES 密钥
4. 本地缓存 `huihuaid`、`AES 密钥`、`客户端公钥`，后续所有加密请求复用
5. 发送加密业务请求时，请求头带 `X-Huihua-Id` 和 `X-Kehugongyao`，请求体用 AES-GCM 加密
6. 收到加密响应后用同一 AES 密钥解密
7. 会话过期（Redis TTL 到期）时，重新从步骤 2 开始

## 依赖分析

项目已有的加密相关依赖，无需新增任何 crate：

- `x25519-dalek`（含 `static_secrets`）— ECDH 密钥协商
- `aes-gcm` — AES-256-GCM 认证加密
- `sha2` — SHA-256 用于 HKDF 密钥派生
- `hmac` — HMAC 用于 HKDF 密钥派生
- `redis` + `deadpool-redis` — 会话密钥临时存储
- `rand` — 安全随机数生成
- `serde` / `serde_json` — 序列化
- `actix-web` — 中间件与路由

## 实现步骤

### 第一步：Redis 连接池模块

在 `src/shujuku/` 下新建 Redis 子系统，与 `psqlshujuku`、`qrshujuku` 平级。

```
src/shujuku/
├── mod.rs                  ← 新增 pub mod redisshujuku
├── psqlshujuku/
├── qrshujuku/
└── redisshujuku/           ← 新建
    ├── mod.rs
    └── redisshujukuzhuti.rs    ← 连接池初始化、全局池获取
```

需要实现的内容：
- 连接配置结构体 `Redispeizhi`（地址、端口、密码、数据库编号）
- 基于 `deadpool-redis` 的全局连接池（`OnceLock` 持有，与 psql 风格一致）
- 连接状态写入内存缓存（与 psql 一致的模式）
- 提供 `lianjie()`、`huoquchi()` 公开方法

同步修改：
- `peizhi/shujuku.json` 新增 redis 配置段
- `src/peizhixt/peizhi_nr/peizhi_shujuku.rs` 新增 `Redis` 配置结构体
- `src/main.rs` 新增 Redis 初始化流程

### 第二步：加密工具模块

在 `src/gongju/` 下新建加密工具文件。

```
src/gongju/
├── mod.rs                  ← 新增 pub mod jiamigongju
├── jichugongju.rs
├── neicungongju.rs
├── wangluogongju.rs
├── wenjiancaozuo.rs
└── jiamigongju.rs          ← 新建
```

需要实现的纯工具函数（失败返回 None，不打印错误）：
- `shengchengyaodui()` → 生成 X25519 临时密钥对（私钥 + 公钥），返回 `Option<(Vec<u8>, Vec<u8>)>`
- `xieshanggonxiangyao(benfangsiyao: &[u8], duifanggongyao: &[u8])` → ECDH 协商共享密钥，返回 `Option<Vec<u8>>`
- `paishengyao(gonxiangyao: &[u8], yanfen: &[u8])` → HKDF-SHA256 从共享密钥派生 32 字节 AES 密钥，返回 `Option<Vec<u8>>`
- `jiami(mingwen: &[u8], miyao: &[u8])` → AES-256-GCM 加密，随机生成 12 字节 nonce，返回 `Option<Vec<u8>>`（nonce + 密文拼接）
- `jiemi(miwen: &[u8], miyao: &[u8])` → AES-256-GCM 解密，从密文前 12 字节提取 nonce，返回 `Option<Vec<u8>>`
- `gongyaozhuanbase64(gongyao: &[u8])` → 公钥转 base64 编码
- `base64zhuangongyao(base64: &str)` → base64 解码为公钥字节

注意：需要在 `Cargo.toml` 中新增 `base64` 依赖用于公钥编码传输。

### 第三步：会话管理模块

在 `src/jiekouxt/` 下新建加密传输子系统。

```
src/jiekouxt/
├── mod.rs                  ← 新增 pub mod jiamichuanshu
├── jiekouxtzhuti.rs
├── jiekou_nr/
└── jiamichuanshu/          ← 新建
    ├── mod.rs
    └── huihuaguanli.rs     ← 会话管理（指纹绑定 + 密钥存取）
```

需要实现的内容：
- `huoquhuochuangjian(zhiwen: &str)` → 根据指纹查找已有会话，有则返回已有公钥+会话ID，无则生成新密钥对存入 Redis，返回公钥+会话ID
- `huoqusiyao(huihuaid: &str)` → 从 Redis 取出服务端私钥
- `yanzhengzhiwen(huihuaid: &str, zhiwen: &str)` → 校验会话是否属于该指纹
- `xuqihuihua(huihuaid: &str)` → 续期会话 TTL（每次使用时刷新过期时间）
- 指纹频率限制：`jiancharate(zhiwen: &str)` → 检查该指纹的请求频率是否超限

Redis 键设计：
- `jiami:huihua:{huihuaid}` → Hash，存储 `{ siyao: "base64私钥", zhiwen: "指纹哈希", gongyao: "base64公钥" }`
- `jiami:zhiwen:{zhiwen}` → 存储该指纹当前活跃的 huihuaid（用于会话复用查找）
- `jiami:pinlv:{zhiwen}` → 频率计数器（短 TTL，用于限制同一指纹的创建频率）

会话 TTL：1800 秒（30 分钟），每次使用时续期，长时间不用自动过期

### 第四步：公钥交换接口

在 `src/jiekouxt/jiekou_nr/` 下新建加密模块。

```
src/jiekouxt/jiekou_nr/
├── mod.rs                  ← 新增 pub mod jiami，注册路由和接口定义
├── xitong/
└── jiami/                  ← 新建
    ├── mod.rs
    └── jiekou_gongyao.rs   ← 公钥交换接口
```

接口定义：
- 路径：`/jiekou/jiami/gongyao`
- 方式：POST（需要提交指纹数据）
- 加密：false（此接口本身不加密）
- 需登录：false
- 请求体：`{ zhiwen: "设备指纹SHA-256哈希" }`
- 响应：`{ huihuaid: "xxx", gongyao: "base64编码的公钥" }`

处理逻辑：
1. 校验指纹格式（必须是 64 位十六进制字符串，即 SHA-256 哈希）
2. 从请求中提取客户端 IP，拼接到指纹校验中（服务端二次验证）
3. 检查该指纹的频率限制
4. 调用会话管理的 `huoquhuochuangjian()`，复用已有会话或创建新会话
5. 返回公钥和会话ID

### 第五步：加密传输中间件

在 `src/jiekouxt/jiamichuanshu/` 下新建中间件文件。

```
src/jiekouxt/jiamichuanshu/
├── mod.rs
├── huihuaguanli.rs
└── jiamichuanshuzhongjian.rs   ← 新建，actix-web 中间件
```

中间件逻辑：
1. 检查接口定义中 `jiami` 字段是否为 `true`，非加密接口直接放行
2. 从请求头提取 `X-Huihua-Id`（会话ID）和 `X-Kehugongyao`（客户端公钥 base64）
3. 从 Redis 获取服务端私钥，校验会话有效性
4. ECDH 协商 → HKDF 派生 → AES-GCM 解密请求体
5. 将解密后的明文替换请求体，传递给业务处理函数
6. 拦截响应体，用同一密钥 AES-GCM 加密后返回
7. 续期会话 TTL（刷新过期时间，保持会话活跃）

请求头设计：
- `X-Huihua-Id` — 会话ID（从公钥交换接口获得）
- `X-Kehugongyao` — 客户端公钥（base64 编码）

### 第六步：集成与挂载

修改现有文件，将加密传输系统集成到框架中：

- `src/jiekouxt/jiekouxtzhuti.rs` 的 `peizhi()` 中挂载加密中间件
- `src/jiekouxt/jiekou_nr/mod.rs` 注册公钥交换路由和接口定义
- `src/main.rs` 添加 Redis 初始化流程

## 文件变更清单

新建文件：
- `src/shujuku/redisshujuku/mod.rs`
- `src/shujuku/redisshujuku/redisshujukuzhuti.rs`
- `src/gongju/jiamigongju.rs`
- `src/jiekouxt/jiamichuanshu/mod.rs`
- `src/jiekouxt/jiamichuanshu/huihuaguanli.rs`
- `src/jiekouxt/jiamichuanshu/jiamichuanshuzhongjian.rs`
- `src/jiekouxt/jiekou_nr/jiami/mod.rs`
- `src/jiekouxt/jiekou_nr/jiami/jiekou_gongyao.rs`

修改文件：
- `Cargo.toml` — 新增 `base64` 依赖
- `peizhi/shujuku.json` — 新增 redis 配置段
- `src/peizhixt/peizhi_nr/peizhi_shujuku.rs` — 新增 Redis 配置结构体
- `src/shujuku/mod.rs` — 新增 `pub mod redisshujuku`
- `src/gongju/mod.rs` — 新增 `pub mod jiamigongju`
- `src/jiekouxt/mod.rs` — 新增 `pub mod jiamichuanshu`
- `src/jiekouxt/jiekou_nr/mod.rs` — 注册加密模块路由和接口定义
- `src/jiekouxt/jiekouxtzhuti.rs` — 挂载加密中间件
- `src/main.rs` — Redis 初始化流程

## 安全设计要点

- 设备指纹绑定：会话与设备指纹绑定，指纹包含 IP、UA、屏幕、时区等多维信息的 SHA-256 哈希，伪造成本高
- 会话复用：同一指纹复用已有会话，减少密钥协商次数，同时防止同一设备无限创建会话
- 指纹频率限制：同一指纹在短时间内创建新会话的次数受限，防止批量刷会话
- 自动续期：会话每次使用时刷新 TTL，活跃会话不会过期，闲置会话自动清理
- 临时密钥对：使用 X25519 临时密钥对，实现前向保密
- 认证加密：AES-GCM 同时提供加密和完整性校验，防止篡改
- HKDF 派生：不直接使用 ECDH 共享密钥，通过 HKDF 派生最终加密密钥，增强安全性
- 随机 nonce：每次加密使用随机 12 字节 nonce，避免 nonce 重用

## 执行顺序

严格按步骤 1 → 2 → 3 → 4 → 5 → 6 的顺序实现，每一步都依赖前一步的产出。
