# 如何创建一个工具

本文档说明如何在本项目中新增一个 AI 工具，供 ReAct 循环调用。

---

## 工具目录结构

```
src/gongju/ai/openai/gongjuji/
├── mod.rs                    # 工具注册中心、分发执行入口
├── gongju_shijianchaxun.rs   # 示例：简单工具（无参数）
├── gongju_aiqudaoguanli.rs   # 示例：复杂工具（多操作类型）
├── guanjianci_suoyin.rs      # Trie 树关键词索引（不需要修改）
└── ceshi_gongjufenzu.rs      # 测试文件（不需要修改）
```

新增一个工具只需要做两件事：

1. 在 `gongjuji/` 下新建一个 `gongju_xxx.rs` 文件
2. 在 `mod.rs` 中注册这个工具

---

## 第一步：新建工具文件

文件命名规范：`gongju_` + 工具功能名，例如 `gongju_yonghuguanli.rs`。

文件必须包含以下四个部分：

### 1. 工具分组枚举

```rust
#[derive(Debug, Clone)]
pub enum Gongjufenzu {
    Guanli,  // 管理组
    Xitong,  // 系统组
}
```

### 2. 关键词列表

AI 会根据用户输入的关键词决定是否调用这个工具，关键词越准确匹配越精确。

```rust
pub fn huoqu_guanjianci() -> Vec<String> {
    vec![
        "用户".to_string(),
        "账号".to_string(),
        "user".to_string(),
        // 中英文都要写
    ]
}
```

### 3. 工具分组

```rust
pub fn huoqu_fenzu() -> Gongjufenzu {
    Gongjufenzu::Guanli  // 或 Gongjufenzu::Xitong
}
```

### 4. 工具定义（dinyi）

用 JSON Schema 描述工具的参数，AI 会按照这个 Schema 生成调用参数。

```rust
use llm::chat::Tool;
use serde_json::json;

pub fn dinyi() -> Tool {
    Tool {
        tool_type: "function".to_string(),
        function: llm::chat::FunctionTool {
            name: "yonghu_guanli".to_string(),           // 工具唯一名称，下划线命名
            description: "管理用户的增删改查操作".to_string(), // 描述要清晰，AI 靠这个理解用途
            parameters: json!({
                "type": "object",
                "properties": {
                    "caozuo": {
                        "type": "string",
                        "description": "操作类型：chaxun=查询，xinzeng=新增，shanchu=删除",
                        "enum": ["chaxun", "xinzeng", "shanchu"]
                    },
                    "id": {
                        "type": "string",
                        "description": "用户ID，shanchu操作时必填"
                    }
                },
                "required": ["caozuo"]  // 必填参数列表
            }),
        },
    }
}
```

### 5. 工具执行（zhixing）

这是工具的实际逻辑，接收 AI 生成的 JSON 参数字符串和用户令牌，返回结果字符串（也是 JSON 格式）。

```rust
use serde::Deserialize;
use serde_json::json;

#[derive(Deserialize)]
struct Qingqiucanshu {
    caozuo: String,
    id: Option<String>,
}

pub async fn zhixing(canshu: &str, lingpai: &str) -> String {
    // 1. 如果需要鉴权，验证令牌
    // let _zaiti = match crate::gongju::jwtgongju::yanzheng(lingpai).await {
    //     Some(z) => z,
    //     None => return json!({"cuowu": "令牌无效或已过期"}).to_string(),
    // };

    // 2. 解析参数
    let qingqiu: Qingqiucanshu = match serde_json::from_str(canshu) {
        Ok(q) => q,
        Err(_) => return json!({"cuowu": "参数格式错误"}).to_string(),
    };

    // 3. 根据操作类型执行逻辑
    match qingqiu.caozuo.as_str() {
        "chaxun" => {
            // 调用数据库或其他服务
            json!({"chenggong": true, "shuju": []}).to_string()
        }
        "xinzeng" => {
            json!({"chenggong": true}).to_string()
        }
        _ => json!({"cuowu": "未知操作类型"}).to_string(),
    }
}
```

**返回格式约定：**
- 成功：`{"chenggong": true, "shuju": ...}`
- 失败：`{"cuowu": "错误说明"}`

---

## 第二步：在 mod.rs 中注册

打开 `src/gongju/ai/openai/gongjuji/mod.rs`，需要修改三处：

### 1. 声明模块

在文件顶部的 `mod` 声明区域添加：

```rust
mod gongju_yonghuguanli;  // 不对外暴露则用 mod，需要外部访问则用 pub mod
```

### 2. 添加包装函数

在其他 `_wrapper` 函数旁边添加：

```rust
fn gongju_yonghuguanli_wrapper(canshu: &str, lingpai: &str) -> Pin<Box<dyn Future<Output = String> + Send + 'static>> {
    let canshu = canshu.to_string();
    let lingpai = lingpai.to_string();
    Box::pin(async move {
        gongju_yonghuguanli::zhixing(&canshu, &lingpai).await
    })
}
```

### 3. 在 suoyouzhuce() 中注册

在 `suoyouzhuce()` 函数的 `vec![]` 中追加一项：

```rust
Gongjuzhuce {
    dinyi: gongju_yonghuguanli::dinyi(),
    zhixing: gongju_yonghuguanli_wrapper,
    xinxi: Gongjuxinxi {
        mingcheng: "yonghu_guanli".to_string(),  // 必须和 dinyi() 里的 name 一致
        guanjianci: gongju_yonghuguanli::huoqu_guanjianci(),
        fenzu: match gongju_yonghuguanli::huoqu_fenzu() {
            gongju_yonghuguanli::Gongjufenzu::Guanli => Gongjufenzu::Guanli,
            gongju_yonghuguanli::Gongjufenzu::Xitong => Gongjufenzu::Xitong,
        },
    },
},
```

---

## 注意事项

- `mingcheng` 字段（工具名）在 `dinyi()` 的 `name` 和 `suoyouzhuce()` 的 `mingcheng` 必须完全一致，否则执行时会找不到工具
- 关键词尽量覆盖用户可能说的各种表达方式，中英文都要写
- `zhixing` 函数的返回值是字符串，AI 会把这个字符串作为工具结果继续推理，所以内容要清晰易读
- 如果工具需要访问数据库，参考 `gongju_aiqudaoguanli.rs` 的写法，调用 `shujuku` 模块
- 如果工具不需要鉴权（比如查询公开信息），可以不验证 `lingpai`

---

## 完整示例参考

| 文件 | 特点 | 适合参考场景 |
|------|------|-------------|
| `gongju_shijianchaxun.rs` | 无参数、无鉴权、逻辑简单 | 查询类、系统信息类工具 |
| `gongju_aiqudaoguanli.rs` | 多操作类型、有鉴权、调用数据库 | 增删改查类工具 |
